Типы для больших значений
#########################

Варианты хранения
*****************

.. 	figure:: img/08_01.png
       :scale: 100 %
       :align: center
       :alt: asda

Для хранения и обработки больших объемов данных в стандарте SQL предусмотрены типы:

- clob (character large object) — для символьных данных;

- blob (binary large object) — для двоичных данных.

В PostgreSQL типы *clob* и *blob* отсутствуют. Вместо них для символьных данных можно использовать тип **text**, а для двоичных —  **bytea** (*byte array*). 
Работа с данными типа **text** не зависит от размера значения, поэтомув дальнейшем будем говорить только о двоичных данных. Например, об изображениях, видео, аудио и пр. 
Как правило такие данные хранят содержимое файлов соответствующих форматов.

В качестве альтернативы типу **byte**a, можно использовать подсистему работы с большими объектами.

Но прежде чем размещать данные файлов внутри базы, следует рассмотреть возможность хранения их «в обычном виде» в файловой системе.

Хранение в файловой системе
===========================

.. 	figure:: img/08_02.png
       :scale: 100 %
       :align: center
       :alt: asda

Если говорить о двоичных данных большого объема, то один из вариантов — отказаться от размещения их в СУБД. 
В этом случае файлы с двоичными данными располагаются непосредственнов файловой системе, а внутри базы данных поддерживаются только ссылки на них.

.. 	figure:: img/08_03.png
       :scale: 100 %
       :align: center
       :alt: asda


Такой подход может быть оправдан в первую очередь производительностью. Скорость чтения и записи файлов увеличивается за счет избежания затрат, характерных для СУБД:

- двойная запись на диск (в WAL и файлы данных);

- двойное кеширование в оперативной памяти (файловый кеши буферный кеш СУБД);

- накладные расходы на хранение в базе данных и обработку (нарезка на фрагменты для хранения и склейка их при чтении);

- возможное распухание таблиц и индексов приводитк дополнительному чтению устаревших фрагментов значения.

Кроме того, удается сократить расходы на обслуживание. Не требуется очистка и переиндексация таблиц с большими данными. Копирование файлов, в том числе инкрементальное, можно выполнять средствами ОС. 
А резервные копии только базы данных будут создаваться быстрее, меньшего размера и потребуют меньше времени на восстановление.

С другой стороны, становится невозможным использовать преимущества СУБД:

- транзакционная обработка: атомарность и согласованность записи, конкурентный доступ, восстановление после сбоя;

- управление доступом пользователей на чтение и запись данных.

Архитектура системы может потребовать пересмотра и доработки процедур резервного копирования и восстановления, использования реплик, обнаружения неиспользуемых файлов и пр.


TOAST
*****

.. 	figure:: img/08_04.png
       :scale: 100 %
       :align: center
       :alt: asda


Любая версия строки в PostgreSQL должна целиком помещаться на одну страницу. Для «длинных» версий строк применяется технология **TOAST — The Oversized Attributes Storage Technique**. 

Точнее, TOAST применяется к отдельным атрибутам, имеющим тип переменной длины, например, **text** и **bytea**, а также **xml** и **json**
. 
В любом случае размер одного значения (возможно сжатого) не должен превышать 1 Гбайта.

Для каждой основной таблицы при необходимости создается отдельная TOAST-таблица (и к ней специальный индекс). Версии строк в TOAST-таблице тоже должны помещаться на одну страницу, 
поэтому «длинные» значения хранятся порезанными на части, обычно около 2 Кбайт. Из этих частей PostgreSQL прозрачно для приложения «склеивает» необходимое значение.

TOAST-таблица используется только при обращении к «длинному» значению. Если эти данные упакованы, то начальные фрагменты сжатого атрибута считываются порциями и сразу распаковываются, 
позволяя избежать извлечения «длинного» значения целиком. Но если требуется изменить несколько байт значения, то оно будет считанои записано полностью.

Для TOAST-таблицы поддерживается своя версионность: если обновление данных не затрагивает «длинное» значение, новая версия строки будет ссылаться на то же самое значение в TOAST-таблице — это экономит место.

Стратегии хранения
==================

.. 	figure:: img/08_05.png
       :scale: 100 %
       :align: center
       :alt: asda


Столбцы таблиц используют одну из четырех стратегий хранения значений, устанавливаемую в зависимости от типа данных:

- **EXTENDED**. Допускается сжатие и перенос в таблицу TOAST.Для типов, поддерживающих перенос в TOAST, обычно используется эта стратегия.

- **EXTERNAL**. Допускается только перенос в таблицу TOAST, но не сжатие. Если загружаемые данные уже сжаты, имеет смысл выбрать стратегию EXTERNAL для экономии затрат на малоэффективное повторное сжатие.

- **MAIN**. Поля с этой стратегией сжимаются только в том случае, если обработки полей EXTENDED и EXTERNAL оказалось недостаточно, чтобы уместить версию строки на странице. Переносв таблицу TOAST тоже возможен, но только как крайняя мера.

- **PLAIN**. Хранение только в основной таблице. Используется для типов, значения которых имеют небольшой размер.

При создании пользовательского типа данных можно задать стратегию, применяемую по умолчанию.

На уровне столбца таблицы можно переопределить стратегию, а также указать метод сжатия.

https://postgrespro.ru/docs/postgresql/16/storage-toast


