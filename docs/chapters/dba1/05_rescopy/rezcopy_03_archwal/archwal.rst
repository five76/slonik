Архив журнала предзаписи
########################

Непрерывная архивация
*********************

.. figure:: img/archwal_01.png
       :scale: 100 %
       :align: center
       :alt: asda

Так как имеется базовая резервная копия и журнал предзаписи, то, добавляя каким-то образом к копии все новые журнальные файлы, генерируемые сервером, 
можно восстановить систему не только на момент копирования файловой системы, но и на произвольный момент времени.

Такая возможность предоставляется путем добавления журнальных записей не к самой резервной копии, а в отдельный «архив». При этом восстановление может 
осуществлено на произвольный момент времени.

Отправка журнальных файлов в архив реализуется фоновым процессом **archiver**, который включается параметром **archive_mode = on**. 
**Требует перезагрузки сервера**.

Для копирования определяется произвольная команда shell в параметре **archive_command**. Она вызывается при заполнении очередного сегмента WAL. 
Если команда завершается с нулевым статусом, то считается, что сегмент успешно помещен в архив и может быть удален с сервера. 
При ненулевом статусе этот сегмент(и следующие за ним) не будут удаляться, а сервер будет периодически повторять команду архивирования, пока не получит 0.
Выполняется непрерывная архивация. Каждый сегмент при заполнении 16 МБ отправляется в архив. Возникает задержка. При активной работе сервера файлы заполняются быстро,
а при низкой (ночью) дольше.

Параметр **archive_timeout** позволяет указать максимальное время переключения на новый сегмент WAL — это позволяет при невысокой активности сервера 
сохранять тем не менее журналы не реже, чем хотелось бы (иными словами, потерять данные максимум за указанное время). Сегмент архива считается заполненным 
и отправляется в архив. 

Переключение на новый сегмент можно выполнить и вручнуюс помощью функции **pg_switch_wal()**.

https://postgrespro.ru/docs/postgresql/13/continuous-archiving

Команда archive_command
***********************

.. figure:: img/archwal_02.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
Команда архивирования должна скопировать указанный файл в некий архив. Архив может быть организован любым образом. 
Например, это может быть файловая система на отдельном сервере.

При заполнении этой команды можно пользоваться символами подстановки - **%p** и **%f**. Файл **%p** копируется в файл **%f**. 

Команда обязана завершаться с *нулевым статусом* только в случае успеха.

Команда не должна перезаписывать уже существующие файлы, так как это скорее всего означает какую-то ошибку, и перезапись файла может погубить архив.

Команда **archive_command** может быть пустой. В таком случае команда возвращает ненулевой статус и сервер будет копить сегменты, не копируя их в архив. 
Этим можно пользоваться в том случае, если нужно произвести какие-то работы над архивом. 

Для гарантии надежности команда должна обеспечить попадание файла в энергонезависимую память: иначе при сбое архива можно потерять сегмент, 
если сервер PostgreSQL успеет его удалить.

Текущий статус архивации показывает представление **pg_stat_archiver**. Удобно включить сбор сообщений с помощью процесса **logging_collector**, 
так как в этом случае сообщения об ошибках при выполнения ar chive_command будут попадать в журнал сервера.

Если подразумевается сложная логика, то ее удобно записать в скрипт и использовать имя скрипта в качестве команды копирования.

https://postgrespro.ru/docs/postgresql/13/runtime-config-wal.html#GUC-ARCHIVE-COMMAND

Практика
--------

**Настройка непрерывной архивации**

Архив будем хранить в каталоге **/var/lib/pgsql/archive**. Он должен быть доступен пользователю-владельцу PostgreSQL.

::

	admin$ sudo mkdir /var/lib/pgsql/archive

::

	admin$ sudo chown postgres /var/lib/pgsql/archive
	
В реальной практике архив может размещаться на отдельном сервере или дисковой системе с доступом по сети.

Включим режим архивирования и установим команду копирования заполненных сегментов журнала.

::

	A@postgres=#\c

::

	A@postgres=#ALTER SYSTEM SET archive_mode = on;

В archive_command мы сначала проверяем наличие файла с указанным именем в архиве, и копируем его только в случае отсутствия.

::

	A@postgres=#ALTER SYSTEM SET archive_command = 'test ! -f /var/lib/pgsql/archive/%f && cp %p /var/lib/pgsql/archive/%f';

В archive_command можно указать произвольную команду, лишь бы она завершалась со статусом 0 только в случае успеха. 
Например, можно организовать сжатие архивируемых сегментов:

::

	A@postgres=# SET archive_command = 'test ! -f /var/lib/pgsql/archive/%f && gzip <%p >/var/lib/pgsql/archive/%f';

В идеале команда архивирования должна выполнять sync, чтобы файл гарантированно попал в энергонезависимую память. 
Иначе при сбое он может пропасть из архива, а сервер может успеть стереть его из каталога **pg_wal**.

В общем случае удобно поместить всю необходимую логику архивирования в отдельный скрипт и вызывать его:

::

	A@postgres=# SET archive_command = 'archive.sh "%f" "%p"';

Изменение **archive_mode** требует рестарта сервера.

::

	[admin@PG ~]$ sudo -u postgres pg_ctl -D /var/lib/pgsql/data  restart

Проверим работу архивации. Создадим базу и таблицу.

::

	admint$ psql -U postgres
	
::

	A@postgres=#CREATE DATABASE backup_archive;

::

	A@postgres=#\c backup_archive

	You are now connected to database "backup_archive" as user "postgres".
::

	CREATE TABLE t(s text);
::

	INSERT INTO t VALUES ('Привет, мир!');

Вот какой сегмент WAL используется сейчас:

::

	SELECT pg_walfile_name(pg_current_wal_lsn());
	
	pg_walfile_name      
	--------------------------
	 000000010000000000000003
	(1 row)

Первые восемь цифр в имени файла — *номер текущей линии времени*.

Чтобы заполнить файл, пришлось бы выполнить большое количество операций. 
В тестовых целях проще принудительно переключить сегмент:

::

	SELECT pg_switch_wal();
	
	 pg_switch_wal 
	---------------
	 0/301C460
	(1 row)
	
::

	INSERT INTO t VALUES ('Доброе утро, страна!');

Сегмент сменился:

::

	SELECT pg_walfile_name(pg_current_wal_lsn());
     
	 pg_walfile_name      
	--------------------------
	 000000010000000000000004
	(1 row)

А предыдущий должен был попасть в архив. Проверим:

::

	admin$ sudo ls -l /var/lib/pgsql/archive

.. figure:: img/archwal_04.png
       :scale: 100 %
       :align: center
       :alt: asda

Текущий статус архивации показывает представление pg_stat_archiver:

::

	A@backup_archive=#SELECT * FROM pg_stat_archiver \gx

.. figure:: img/archwal_03.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
Таким образом, файловая архивация настроена и работает.

