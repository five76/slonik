Базовая резервная копия
#######################

Физическая копия
****************

Физическое резервирование подразумевает копирование всех файлов, относящихся к кластеру БД, то есть создание полной двоичной копии.

Копирование файлов работает быстрее, чем выгрузка SQL-команд при логическом резервировании; запустить сервер из созданной физической копии — дело нескольких минут, 
в отличие от восстановления из логической копии. При этом статистика также восстанавливается из копии, нет необходимости ее собирать заново.

К недостаткам можно отнести тот факт, что из физической резервной копии можно восстановить систему только на совместимой платформе 
(та же ОС, та же разрядность, тот же порядок байтов в представлении чисел и т. п.) и только на той же основной версии PostgreSQL.
Восстанавливаться между разными операционными системами или между 15-м и 16 Postgres не получится. 

Кроме того, невозможно сделать физическую копию отдельных баз данных кластера, возможно копирование только всего кластера целиком.

Холодное резервирование
***********************

.. figure:: img/baserezcopy_01.png
       :scale: 100 %
       :align: center
       :alt: asda

Смысл холодного резервирования состоит в том, чтобы сделать копию файловой системы в тот момент, когда она содержит согласованные данные. 
Восстановление из такой копии происходит просто: файлы разворачиваются, запускается сервер — и он сразу же готов к работе.

Единственный вариант сделать такую копию — остановить сервер с выполнением контрольной точки. 
Необходима *остановка* сервера (которая к тому же может оказаться длительной при большом объеме данных), что является очевидным недостатком этого способа.

Время простоя можно сократить за счет предварительного выполнения *rsync* (или аналогичного инструмента) при работающем сервере. 
Тогда после останова сервера *rsync* докопирует только изменения (которых, предположительно, будет не много). 
Но простоя все равно не избежать.

Другой вариант — сделать копию несогласованных данных. 
Такая ситуация может возникнуть при неаккуратном отключении сервера или при создании снимка файловой системы 
(если ФС имеет такую возможность, и если все необходимые файлы попадают в один снимок). При этом потребуются файлы журнала pg_wal.

В этом случае восстановление происходит аналогично, но при старте серверу потребуется выполнить восстановление согласованности. 
Это обычная автоматическая процедура восстановления после сбоя. Она не представляет проблемы, так как необходимые файлы журнала гарантированно попадут в копию, 
но она потребует некоторого времени.

https://postgrespro.ru/docs/postgresql/13/backup-file

Практика

Холодная файловая копия

Файлы остановленного кластера можно скопировать и запустить с ними второй сервер. При этом не важно, был ли сервер остановлен корректно.

Создадим базу данных и таблицу.

::

	admin$ sudo -u postgres pg_ctl -D /var/lib/pgsql/data  start

	admin$ psql -U postgres 

::
	postgres=# CREATE DATABASE backup_base;


::

	postgres=# \c backup_base

	postgres=#  CREATE TABLE t(s text);

	postgres=#  INSERT INTO t VALUES ('Привет, мир!');

Аварийно останавливаем сервер и копируем файлы на сервер beta:

::

	admin$  sudo -u postgres head -1  /var/lib/pgsql/data/postmaster.pid
	
	41066

::

	admin$ sudo -u postgres kill -9 41066

::

	admin$ sudo -u postgres pg_ctl -D /var/lib/pgsql/data1 status

	pg_ctl: no server running
	
::

	admin$ sudo -u postgres rm -rf /var/lib/pgsql/data1

::

	admin$ sudo -u postgres cp -rp /var/lib/pgsql/data /var/lib/pgsql/data1

Сам резервный сервер уже предварительно собран и установлен.

Beta восстанавливает согласованность и запускается:

::

	admindb$ sudo -u postgres pg_ctl -D /var/lib/pgsql/data1  start

::

	admindb$  sudo -u postgres tail -n 5 /var/lib/pgsql/data1/log/postgresql-2025-07-24_084400.log

.. figure:: img/baserezcopy_02.png
       :scale: 100 %
       :align: center
       :alt: asda

::

	psql -U postgres
	
::

.. figure:: img/baserezcopy_03.png
       :scale: 100 %
       :align: center
       :alt: asda

::

	admindb$ sudo -u postgres pg_ctl -D /var/lib/pgsql/data1  stop

Горячее резервирование
**********************

Горячее резервирование выполняется на работающем сервере, поэтому в копию попадут несогласованные данные.

Также при резервном копировании данные читаются не через буферный кеш, а напрямую из файлов. 
Содержимое файлов на диске, очевидно, изменяется во время копирования, а файловая система обычно не гарантирует атомарность чтения/записи 
8-килобайтной страницы PostgreSQL. Postgres оперирует страницами размером 8 килобайт, а операционная система, как правило, оперирует блоками меньшего размера. 
Пока файл читается, в него одновременно другие процессы пишут. 
Поэтому в резервную копию будут попадать «безнадежные» страницы, к которым даже нельзя применить журнальные записи. 
Для борьбы с этой проблемой используется параметр **full_page_writes**, который говорит о том, что при после 
каждой контрольной точки, когда в первый раз записываются изменения в странице, то записывается не только это изменение, а вся страница целиком.
И только если дальше к этой странице будут применяться какие-то изменения, то будут уже записываться уже эти отдельные изменения.

Для восстановления из такой горячей резервные копии потребуются все журнальные записи от начала последней контрольной точки, 
которая была выполнена перед началом копирования данных, а также все журнальные записи от начала и до самого конца копирования файлов данных. 

Другая сложность состоит в том, что копирование файлов данных может занимать достаточно много времени. 
Но сервер, после выполнения очередной контрольной точки, может удалить часть файлов журнала, которые уже не нужны ему для восстановления после сбоя, 
но нужны для резервной копии.

Если не принять специальных мер, сделанная резервная копия будет непригодна для восстановления. 
Поэтому для горячего резервирования требуются специальные инструменты. PostgreSQL предоставляет низкоуровневый интерфейс, 
используя который можно реализовать надежное копирование. Этот интерфейс  использует и штатная утилита **pg_basebackup**, 
и другие сторонние средства резервного копирования.

https://postgrespro.ru/docs/postgresql/13/continuous-archiving.html#BACKUP-BASE-BACKUP

Протокол репликации
*******************

.. figure:: img/baserezcopy_04.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
Для упрощения задачи, сервер PostgreSQL предоставляет протокол репликации — специальный протокол для управления как собственно репликацией, 
так и резервным копированием. В частности, он позволяет получать поток журнальных записей, которые генерирует сервер.

.. note:: Протокол репликации в информационных системах — это механизм, который обеспечивает синхронизацию копий данных (реплик) на нескольких узлах системы. 
          Цель репликации — обеспечить доступность данных, повысить отказоустойчивость и улучшить производительность системы. 
		  Например, в контексте баз данных репликация позволяет создавать и хранить дубликаты базы данных на нескольких серверах или узлах, что помогает справляться с ситуациями отказа в работе одного из серверов

На сервере подключение по протоколу репликации обслуживается процессом **wal sender**. 
Он похож на обычный обслуживающий процесс, который запускается при обычном подключении клиента, но понимает не SQL, а специальные команды. 
Число одновременно работающих процессов **wal_sender** ограничено значением параметра **max_wal_senders**.

Уровень журнала должен быть не ниже, чем **replica**. Дело в том, что на уровне **minimal** такие команды, как *CREATE TABLE AS SELECT, CREATE INDEX, COPY FROM*, 
не попадают в журнал: их долговечность обеспечивается тем, что данные не остаются в оперативной памяти,а сразу записываются на диск. 
Этого достаточно для восстановления после сбоя и из холодной копии, но недостаточно для восстановления из горячей копии.

Чтобы использовать протокол репликации, клиент должен подключаться к серверу под ролью, имеющей атрибут **REPLICATION** (либо под **суперпользователем**). 
В **pg_hba.conf** надо разрешить подключение этой роли к базе данных **replication** (это, конечно, не название БД, а ключевое слово). 
Причем разрешения для **all** недостаточно, **replication** должен быть разрешен отдельно.

https://postgrespro.ru/docs/postgresql/13/protocol-replication

