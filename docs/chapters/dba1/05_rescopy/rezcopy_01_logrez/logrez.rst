Логическое резервирование
#########################

Логическая копия
****************

Логическое резервирование — набор команд SQL, восстанавливающих кластер (или базу данных, или отдельную таблицу) с нуля: 
создаются необходимые объекты и наполняются данными.

Команды можно выполнить на другой версии СУБД (при наличии совместимости на уровне команд) или на другой платформе и архитектуре (не требуется двоичная совместимость).
Можно создавать, делать копию не целиком всей базы данных, а только одного отдельного объекта. 

В частности, логическую резервную копию можно использовать для долговременного хранения: ее можно будет восстановить и после обновления сервера на новую версию (восстановиться на другой основной версии Postgres)

Однако для большой базы команды могут выполняться очень долго по сравнению, например, с операцией физического копирования файлов.

Восстановить систему из логической копии можно ровно на момент начала резервного копирования.


COPY (команда SQL)
******************

**Серверный вариант**

.. figure:: img/logrez_01.png
       :scale: 100 %
       :align: center
       :alt: asda

**COPY** - сохранения содержимого только одной таблицы.

Команда позволяет записать таблицу (или часть столбцов таблицы, или даже результат произвольного запроса) либо в файл, либо на консоль, либо на вход какой-либо программе. 
Эти же табличные данные из внешнего источника можно будет загрузить таблицу обратно.

При этом можно указать ряд параметров, таких как формат (текстовый, CSV или двоичный). Для текстового формата указать разделитель полей, текстовое представление NULL и т. п.
Файл будет создаваться в файловой системе сервера, где установлен Postgres, и принадлежать будет пользователю, владельцу экземпляра Postgres. 

Другой вариант команды, наоборот, считывает из файла или из консоли строки с полями и записывает их в таблицу. 
Команда **COPY** **не выгружает структуру таблицы**, она выгружает **только данные**. И при загруке данных таблица уже должна быть. 
Если в этой таблице есть какие-то строки, то команда COPY просто добавит из файла строки к уже имеющимся. 

Таблица при этом не очищается, новые строки добавляются к уже существующим.

Команда COPY работает существенно быстрее, чем аналогичные команды INSERT — клиенту не нужно много раз обращаться к серверу, а серверу не нужно много раз анализировать команды.

Тонкость: при выполнении команды COPY FROM не применяются правила (rules), хотя ограничения целостности и триггеры выполняются.

Команда psql \copy
******************

**Клиентский вариант**

.. figure:: img/logrez_02.png
       :scale: 100 %
       :align: center
       :alt: asda

В отличие от серверного варианта COPY, который является командой SQL, клиентский вариант — это команда psql.

Указание имени файла в команде SQL соответствует файлу на сервере БД. У пользователя, под которым работает PostgreSQL (обычно postgres), должен быть доступ к этому файлу.

В клиентском же варианте обращение к файлу происходит на клиенте, а на сервер передается только содержимое. 

Синтаксис команд аналогичный.

https://postgrespro.ru/docs/postgresql/13/app-psql#APP-PSQL-META-COMMANDS-COPY

Практика
========

Создадим базу данных и таблицу.

::

	postgres=# CREATE DATABASE db1;

CREATE DATABASE

::

	postgres=# \c db1

You are now connected to database "db1" as user "student".

::

	postgres=# CREATE TABLE t(
					id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
					s text
				);
CREATE TABLE

::

	postgres=# INSERT INTO t(s) VALUES ('Привет, мир!'), (''), (NULL);

INSERT 0 3

.. figure:: img/logrez_03.png
       :scale: 100 %
       :align: center
       :alt: asda

Вот что показывает команда COPY (выдаем на консоль, а не в файл):

::

	postgres=# COPY t TO stdout;


.. figure:: img/logrez_04.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
Копирование в файл:

::

	COPY t TO '/var/lib/pgsql/data/db1_t.copy';
	   
Видно, как различаются в выводе пустые строки и неопределенные значения.

Формат вывода настраивается достаточно гибко. Можно изменить разделитель, представление неопределенных значений и т. п. Например:

::

	postgres=# COPY t TO stdout WITH (NULL '<NULL>', DELIMITER ',');


1,Привет\, мир!
2,
3,<NULL>

Обратите внимание, что *символ-разделитель* внутри строки был экранирован (символ для экранирования тоже настраивается).

Вместо таблицы можно указать произвольный запрос.

::

	postgres=# COPY (SELECT * FROM t WHERE s IS NOT NULL) TO stdout;

1	Привет, мир!
2	


Таким образом можно сохранить результат запроса, данные представления и т. п.

Команда поддерживает вывод в формате CSV, который поддерживается множеством программ.

::

	postgres=# COPY t TO stdout WITH (FORMAT csv);


1,"Привет, мир!"
2,""
3,

Аналогично работает и ввод данных из файла или с консоли.

::

	postgres=# TRUNCATE TABLE t;

TRUNCATE TABLE


Но при вводе с консоли требуется маркер конца файла — обратная косая черта с точкой; в обычном файле он не нужен.

Чтобы данные загрузились, при вводе надо указать те же параметры, что были указаны при выводе.

При загрузке также можно указать условие:

::

	postgres=# COPY t FROM stdin WHERE id != 2;

	1	Привет, мир!
	2	
	3	\N
	\.

COPY 2

Вот что загрузилось в таблицу (для наглядности настроим в psql вывод неопределенных значений):

::

	postgres=# \pset null '\\N'

Null display is "\N".

::
	
	postgres=# SELECT * FROM t;

.. figure:: img/logrez_05.png
       :scale: 100 %
       :align: center
       :alt: asda

Загрузим все строки из файла:

::

	postgres=# TRUNCATE TABLE t;
	
::

	
	postgres=# COPY t FROM '/var/lib/pgsql/data/db1_t.copy';
	
.. figure:: img/logrez_06.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
Копия базы данных
*****************

Для создания полноценной резервной копии базы данных используется утилита **pg_dump**.

Если не указать имя файла (-f, --file), то утилита выведет результат на консоль. 

Результатом является скрипт, предназначенный для psql, который содержит команды для создания необходимых объектов и наполнения их данными.
Представлен он обычным файлом в plian формате.

Pgdump это отдельная утилита, поэтому она может запускаться как на сервере, так и на клиенте. 
Соответственно, в зависимости от того, где она запущена там и будет формироваться копия.

Дополнительными ключами утилиты можно ограничить набор объектов: выбрать указанные таблицы, или все объекты в указанных схемах, или наложить другие фильтры.

Чтобы восстановить объекты из резервной копии, достаточно выполнить полученный скрипт в psql.

..important:: - Базу данных для восстановления надо создавать из шаблона **template0**, так как все изменения, сделанные в template1, также попадут в резервную копию.
			  - Заранее должны быть созданы необходимые **роли** и **табличные пространства**. Так как это глобальные объекты и не относятсяк конкретной БД, они не будут выгружены в резервную копию.

После восстановления базы, если сразу нужно использовать данные для работы, то имеет смысл выполнить команду ANALYZE: она соберет статистику, 
необходимую оптимизатору для планирования запросов.

https://postgrespro.ru/docs/postgresql/13/app-pgdump