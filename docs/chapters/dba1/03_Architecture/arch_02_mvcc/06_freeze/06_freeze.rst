Заморозка
#########

Каждой транзакции присваивается уникальный идентификатор VirtualTransactionId (также именуемый virtualXID или vxid), 
который состоит из идентификатора обслуживающего процесса (или backendID) и последовательно назначаемого номера — внутреннего для такого обслуживающего процесса (или localXID). 

Например, виртуальный идентификатор 4/12532 состоит из следующих компонентов: backendID со значением 4 и localXID со значением 12532.

Невиртуальные идентификаторы TransactionId (или xid), например 278394, последовательно выбираются для транзакций из глобального счётчика, 
который используется всеми базами данных в рамках кластера PostgreSQL. Значение присваивается *при первой операции записи* транзакции в базу данных. 
Это означает, что транзакции с меньшими xid начинают запись раньше транзакций с большими xid. 
При этом порядок, в котором транзакции выполняют запись в базу данных впервые, может отличаться от порядка, в котором они запускаются, 
особенно если транзакции начинаются с операторов, выполняющих только операции чтения.

Внутренний тип идентификаторов транзакций xid имеет размер 32 бита, и значения в нём повторяются через каждые 4 миллиарда транзакций. 
  
Идентификаторы используются в качестве основы механизма многоверсионного управления конкурентным доступом MVCC PostgreSQL.

4 миллиарда - значение большое, но достижимое. Например, при нагрузке 1000 транзакций в секунду это произойдет всего через полтора месяца непрерывной работы.
Когда номера закончатся, то на этом закончится многоверсионность. Кластер столкнётся с зацикливанием идентификаторов транзакций: 
счётчик XID прокрутится до нуля, и внезапно транзакции, которые относились к прошлому, окажутся в будущем — это означает, 
что их результаты станут невидимыми. А это **катастрофическая потеря данных**. На самом деле данные в файлах останутся, но получить их будет нельзя.

Для того чтобы этого избежать, необходимо выполнять очистку для каждой таблицы в каждой базе данных как минимум единожды на два миллиарда транзакций.

Периодическое выполнение очистки решает эту проблему, потому что процедура VACUUM помечает строки как *замороженные*, 
указывая, что они были вставлены транзакцией, зафиксированной достаточно давно, так что эффект добавляющей транзакции с точки зрения 
MVCC определённо будет виден во всех текущих и будущих транзакциях. 

Вместо "линейной" схемы возраста транзакций используется схема "кольцо":


.. figure:: img/freeze_01.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
Для любой транзакции половина номеров «против часовой стрелки» считается принадлежащей прошлому, а половина «по часовой стрелке» — будущему.
Возрастом транзакции называется число транзакций, прошедших с момента ее появления в системе (независимо от того, переходил ли счетчик через ноль или нет).

Например, на рисунке выше возраст транзакции 1 становится равным 1, когда появляется транзакция 2. (В действительности, номера транзакций 0-2 зарезерывированы).

Ситуация, которая может привести к краху возникает, когда транзакция, находившаяся в далеком прошлом, через некоторое время окажется в той половине круга, 
которая относится к будущему. Отсюда нарушение правил видимости и ошибка.

.. figure:: img/freeze_02.png
       :scale: 100 %
       :align: center
       :alt: asda
	   

Обычные значения XID сравниваются по модулю 2^32. Это означает, что для каждого обычного XID существуют два миллиарда значений XID, которые «старше» него, 
и два миллиарда значений, которые «младше» него; другими словами, пространство значений XID циклично и не имеет конечной точки. 
Следовательно, как только создаётся версия строки с обычным XID, для следующих двух миллиардов транзакций эта версия строки оказывается «в прошлом», 
неважно о каком значении обычного XID идет речь. 
Если после двух миллиардов транзакций эта версия строки всё ещё существует, она внезапно окажется в будущем. 
Для того чтобы это предотвратить, в какой-то момент значение XID для старых версий строк должно быть заменено на FrozenTransactionId 
(заморожено) до того, как будет достигнута граница в два миллиарда транзакций. 

Чтобы не допустить подобных конфликтов, процесс очистки кроме непосредственно очистки осуествляет поиск старых и «холоднхе» версий строк 
(которые видны во всех снимках и изменение которых уже маловероятно) и специальным образом помечает —  «замораживает» — их. 
Замороженная версия строки считается старше любых обычных данных и всегда видна во всех снимках данных. 
При этом уже не требуется смотреть на номер транзакции *xmin*, и этот номер может быть безопасно использован заново. 
Таким образом, замороженные версии строк всегда остаются в прошлом.
Задача заморозки и состоит в том, чтобы гарантировать отсутствие очень старых номеров в поле *xmin*.

.. figure:: img/freeze_03.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
Признаком "замораживания" xmin у старой версии строки выставляются одновременно оба бита-подсказки — бит фиксации и бит отмены (xmin_committed, xmin_aborted)
При этом xmax замораживать не нужно. Ее наличие означает, что данная версия строки больше не актуальна. 
После того, как она перестанет быть видимой в снимках данных, такая версия строки будет очищена.
Сам номер в xmin остается для цели отладки.



.. important:: Важно, чтобы версии строк замораживались вовремя. 
			   Если возникнет ситуация, при которой еще не замороженный номер транзакции рискует попасть в будущее, PostgreSQL аварийно остановится. 

Это возможнов двух случаях: либо транзакция не завершена и, следовательно, не может быть заморожена, либо не сработала очистка.
При запуске сервера транзакция будет автоматически отменена; дальше администратор должен вручную выполнить очистку, и после этого система сможет продолжить работу.

Настройка заморозки
*******************

vacuum_freeze_min_age
-----------------------

Заморозкой управляют четыре основных параметра. Параметр **vacuum_freeze_min_age** определяет минимальный возраст транзакции xmin, с которого начинается заморозка.
То есть насколько старым должен стать XID, чтобы строки с таким XID были заморожены. 
Увеличение его значения помогает избежать ненужной работы, то есть строки активно изменяются и их пока не надо замораживать.
А уменьшение приводит к увеличению количества транзакций, которые могут выполниться, прежде чем потребуется очередная очистка таблицы.
Поэтому более молодые версии строк замораживаются только в тех случаях, когда это точно не добавляет работы, например, если в странице уже требуется заморозка других 
(более старых) строк или при полной очистке таблицы. 

.. important:: Очистка просматривает только страницы, не отмеченные в карте видимости. 

Если на странице остались только актуальные версии, то очистка не придет в такую страницу и не заморозит их. 
В заголовке табличной страницы также имеется признак видимости всех версий строк в ней; очистка использует его вместе с соответствующей отметкой в карте видимости.
Таким образом, обычная команда VACUUM не всегда замораживает все старые версии строк, имеющиеся в таблице. 
Когда это имеет место, операция VACUUM в конце концов должна провести *агрессивную очистку* и заморозить все подходящие незамороженные значения XID и MXID, 
в том числе на полностью видимых, но не полностью замороженных страницах.

.. note:: На практике периодическая агрессивная очистка требуется для большинства таблиц. 

vacuum_freeze_table_age
-----------------------

Параметр *vacuum_freeze_table_age* определяет возраст транзакции, при котором пора выполнять заморозку версий строк на всех страницах таблицы. 
Такая заморозка называется «агрессивной». 

Для каждой таблицы хранится номер транзакции (*pg_class.relfrozenxid*), для которого известно, что в версиях строк не осталось более старых незамороженных номеров транзакций. 
Возраст этой транзакциии сравнивается со значением параметра.



Чтобы не просматривать всю таблицу целиком, вместе с картой видимости ведется карта заморозки.  
В ней отмечены страницы,в которых заморожены все версии строк. Такие страницы при заморозке можно пропускать. 
Даже в агрессивном режиме все версии строк с транзакциями младше vacuum_freeze_min_age не замораживаются, поэтому после заморозки новый возраст транзакции relfrozenxid будет равен не нулю,а vacuum_freeze_min_age. Таким образом, заморозка всех страниц выполняется раз в (vacuum_freeze_table_age − vacuum_freeze_min_age) транзакций.Мы уже говорили, что слишком маленькое значение параметра vacuum_freeze_min_age увеличивает накладные расходы на очистку.Но при больших значениях агрессивная заморозка будет выполняться слишком часто, что тоже плохо. Установка этого параметра требует компромисса.