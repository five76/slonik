Очистка
#######

Механизм многоверсионности позволяет эффективно реализовать изоляцию на основе снимков, 
но в результате в табличных страницах  накапливаются старые версии строк, а в страницах индексов — ссылки на эти версии. 
Какое-то время исторические версии нужны, чтобы транзакции могли работать со своими снимками данных. 
Но со временем не остается ни одного снимка данных, которому требовалась бы старая версия строки; 
такая версия называется «мертвой». 

Для освобождения от таких строк используется процедура очистки.

Процедура очистки вычищает мертвые версии строк из табличных страниц и ненужные индексные записи, 
которые ссылались на такие версии. Если своевременно не вычищать исторические данные, 
таблицы и индексы будут неконтролируемо разрастаться и поиск в них актуальных версий строк будет замедляться.

Самоочистка таблицы выполняется быстро, но не решает всех задач. Она работает только в пределах одной табличной страницы и не затрагивает индексы.

Обычная очистка
***************

Основная, "обычная" очистка выполняется командой **VACUUM**.


Очистка обрабатывает таблицу полностью. Она вычищает не только ненужные версии строк, но и ссылки на них из всех индексов.

Обработка происходит параллельно с другой активностью в системе. 
Таблица и индексы при этом могут использоваться обычным образом и для чтения, и для изменения 
(однако одновременное выполнение таких команд, как CREATE INDEX, ALTER TABLE и некоторых других будет невозможно).

В таблице просматриваются только те страницы, в которых происходила какая-то активность. 
Для этого используется карта видимости (visibility map). 

В карте видимости отмечены страницы, которые *содержат только актуальные версии строк*, причем эти версии видны во всех снимках данных. 
Такие страницы давно не изменялись и успели полностью очиститься от неактуальных версий.Карта видимости применяется:

- Для оптимизации очистки. В отмеченные страницы очистке не надо заглядывать — в них не может быть мертвых версий.

- Для ускорения доступа только по индексу. Информация о версионности хранится только для таблиц, но не для индексов 
(поэтому у индексов не бывает карты видимости). Получив из индекса ссылку на версию строки, нужно прочитать табличную страницу, 
чтобы проверить ее видимость. Но если в самом индексе уже есть все нужные столбцы, и при этом страница отмечена в карте видимости, 
то обращения к таблице можно избежать. 

Если не обновлять карту видимости, индексный доступ будет работать менее эффективно. 

При очистке обрабатываются только те *страницы, которые не отмечены в карте видимости*, а сама карта при этом обновляется.

В процессе работы обновляется и *карта свободного пространства* (free space map) - структура, которая позволяет быстро искать страницы с заданным количеством свободного места. 

В карте свободного пространства отмечен объем пустого места внутри страниц. 
Этот объем постоянно меняется: при добавлении новых версий строк он уменьшается, при очистке — увеличивается. 

Карта используется *при вставке новых версий строк*, чтобы быстро найти подходящую страницу, на которую поместятся добавляемые данные. 
Для ускорения поиска карта свободного пространства имеет сложную древовидную структуру. Строится для кучи (страницы), а также для всех индексов, кроме hash-индекса. 
У каждой таблицы и каждого индекса свой отдельный FSM.

Простая команда VACUUM только высвобождает пространство и делает его доступным для повторного использования. 
Однако освобождённое место не возвращается операционной системе (в большинстве случаев); оно просто остаётся доступным для размещения 
данных этой же таблицы.

Чтобы очистить таблицу, обычно нужно быть *владельцем* этой таблицы или *суперпользователем*. 
Однако владельцам баз данных также разрешено сжимать все таблицы в своих базах, за исключением общих каталогов. 

VACUUM при обработке пропускает все таблицы, на очистку которых текущий пользователь не имеет прав.

VACUUM нельзя выполнять внутри блока транзакции.

Можно отказаться от очистки основной таблицы или ее TOAST-части, выключив параметры PROCESS_MAIN или PROCESS_TOAST (по умолчанию оба включены).

Команды VACUUM в PostgreSQL должны обрабатывать каждую таблицу по следующим причинам:

- Для высвобождения или повторного использования дискового пространства, занятого изменёнными или удалёнными строками.

- Для обновления статистики по данным, используемой планировщиком запросов PostgreSQL.

- Для обновления карты видимости, которая ускоряет сканирование только индекса.

- Для предотвращения потери очень старых данных из-за зацикливания идентификаторов транзакций или мультитранзакций.


Пример:
=======

1. Создать функцию для просмотра содержимого страницы указанной таблицы:

::

	CREATE FUNCTION heap_page(relname text, pageno integer)
	RETURNS TABLE(ctid tid, state text, xmin text, xmax text, hhu text, hot text, t_ctid tid)
	AS $$
	SELECT (pageno,lp)::text::tid AS ctid,
		   CASE lp_flags
			 WHEN 0 THEN 'unused'
			 WHEN 1 THEN 'normal'
			 WHEN 2 THEN 'redirect to '||lp_off
			 WHEN 3 THEN 'dead'
		   END AS state,
		   t_xmin || CASE
			 WHEN (t_infomask & 256) > 0 THEN ' (c)'
			 WHEN (t_infomask & 512) > 0 THEN ' (a)'
			 ELSE ''
		   END AS xmin,
		   t_xmax || CASE
			 WHEN (t_infomask & 1024) > 0 THEN ' (c)'
			 WHEN (t_infomask & 2048) > 0 THEN ' (a)'
			 ELSE ''
		   END AS xmax,
		   CASE WHEN (t_infomask2 & 16384) > 0 THEN 't' END AS hhu,
		   CASE WHEN (t_infomask2 & 32768) > 0 THEN 't' END AS hot,
		   t_ctid
	FROM heap_page_items(get_raw_page(relname,pageno))
	ORDER BY lp;
	$$ LANGUAGE SQL;

2. Создать функцию для просмотра индексной страницы:

::

	CREATE FUNCTION index_page(relname text, pageno integer)
	RETURNS TABLE(itemoffset smallint, ctid tid)
	AS $$
	SELECT itemoffset,
		   ctid
	FROM bt_page_items(relname,pageno);
	$$ LANGUAGE SQL;
	
3. Создать таблицу, отключив процесс автоочистки:

::

	CREATE TABLE vac(
	  id serial,
	  s char(100)
	) WITH (autovacuum_enabled = off);

4. Создать индекс:

::

	CREATE INDEX vac_s ON vac(s);
	
5. Вставить строку и выполнить несколько обновлений:

::

	INSERT INTO vac(s) VALUES ('A');
	UPDATE vac SET s = 'B';
	UPDATE vac SET s = 'C';

6. В таблице создано три строки и на каждую имеется ссылка из индекса:

::

	SELECT * FROM heap_page('vac',0);
	
::

	SELECT * FROM index_page('vac_s',1);


.. figure:: img/vac_01.png
       :scale: 100 %
       :align: center
       :alt: asda


7. После очистки «мертвые» версии пропадают и остается только одна, актуальная. И в индексе тоже остается одна ссылка:

::
	
	VACUUM vac;
	
	SELECT * FROM heap_page('vac',0);
	
	SELECT * FROM index_page('vac_s',1);
	
.. figure:: img/vac_02.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
При внутристраничной очистке указатели бы получили статус *dead* и на них были бы указатели из индекса.



https://habr.com/ru/articles/806415/

Документация VACUUM:

https://postgrespro.ru/docs/postgresql/16/sql-vacuum

https://postgrespro.ru/docs/postgresql/16/routine-vacuuming

.. figure:: img/vac_01.png
       :scale: 100 %
       :align: center
       :alt: asda

