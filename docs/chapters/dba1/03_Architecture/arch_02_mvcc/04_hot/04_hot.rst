HOT-обновления и самоочистка
############################

При работе с данными в табличных страницах появляются новые версии строк. В случае, когда по какому-то из полей строится индекс, 
то необходимо выполнять синхронизацию между таблице и индексом. В индексных страницах появляются записи, указывающие на каждую версию
строки. Это приводит к изменению большого числа страниц и также снижает производительность.

Когда в индексной странице (B-tree) не хватает места, то она разделяется на две и обратно уже ее соединить нельзя, даже когда будет выполнена очистка.
А это означает, что размер индекса не изменится при удалении ненужных данных. Единственным выходом является перестроение индекса.

Сам процесс очистки данных требует значительных ресурсов, поэтому имеются инструменты, которые позволяют чистить страницы при простом к ним обращении.

При обычном обновлении возникают проблемы:

.. figure:: img/hot_01.png
       :scale: 100 %
       :align: center
       :alt: asda

1) при любом изменении строчки в таблице необходимо менять все индексы, которые в этой таблице есть. Обновлять их. 
Соответственно, страдает производительность вставки и изменений данных. 

2) в индексе, так же как и в таблице, накапливаются неактуальные строки, ссылающиеся на неактуальные версии внутри таблицы, 
которые потом нужно из индекса вычищать. При этом индекссная страница может и поделиться.

Чем больше индексов, тем больше всяких проблем, тем больше страдает производительность и увеличивается объем. 

Поэтому для случая, когда изменяются данные в столбцах **не входящих в индекс**, то нет никакого смысла создавать дополнительную запись в B-дереве, 
содержащую то же самое значение ключа



HOT обновление
***************

.. figure:: img/hot_02.png
       :scale: 100 %
       :align: center
       :alt: asda

**HOT* сокращенно от *Heap-Only Tuple Update*.

*Tuple* - это версия строки, а *heap-only это значит, что эта версия строки существует только внутри таблицы, но не в индексе. 

При последующих обновлениях внутри табличной страницы будет появляться цепочка связанных версий.
Каждая будет указывать на следующую в списке, по которой надо пройтись, чтобы получить все нужные версии. 

Для того чтобы можно было обнаружить возможность перемещаться по цепочке в заголовке имеются 2 бита: *heap-hot-updated* и *heap-only-tuple*.

- строки, которые изменены и входят в цепочку и обновлены, маркируются битом Heap Hot Updated;

- строки, на которые нет ссылок из индекса, маркируются битом Heap Only Tuple (то есть — «только табличная версия строки»);

- поддерживается обычная связь версий строк через поле ctid.

При таком обновлении в индексной странице находится лишь одна запись, ссылающаяся на самую первую версию строки в табличной странице. 
А уже внутри этой табличной страницы организуется цепочка версий.

При полное сканировании таблицы без индексов, версии строчек будут найдены, потому что будут прочитаны все версии.
А при попадании в таблицу из индекса, происходит переход по ссылке на первую версию, а потом проход по hot-цепочке (по цепочке ctid).

.. important:: HOT-обновления работают только в случае, если не изменяется **ни один ключ в индексах**.

Причем это касается всех индексов, которые созданы на таблице. 
То есть если ни один индекс не затронут, то в этом случае ход обновления можно применить. 
Если у нас есть хотя бы один индекс по какому-то столбцу, который поменялся, то это значит, что в этом индексе необходимо будет создать ссылку 
на определенную версию строчки, новую, что означает, что ее нельзя пометить  как HOT, 
то есть на нее есть ссылка из какого-то индекса, и поэтому оптимизация работать не будет.

Оптимизация действует только в пределах одной страницы, поэтому дополнительный обход цепочки не требует обращения к 
другим страницам и не ухудшает производительность.

Если на странице не хватит свободного места, чтобы разместить новую версию строки, цепочка прервется. 
На версию строки, размещенную на другой странице, придется сделать отдельную ссылку из индекса.


Поэтому при частых обновлениях неиндексированных полей может иметь смысл уменьшить параметр хранения 
*fillfactor*, определяющий *пороговый процент* занятого на странице места, **после которого вставка новых строк** в эту страницу будет **запрещена**. 
Значение по умолчанию – 100%, можно уменьшать до 10%. Оставшееся место резервируется для **обновлений**: 
в этом случае новая версия строки может занять свободное место на той же странице.

Практика:
=========

Создать таблицу без индекса.

Каждая строка таблицы состоит из 2000 символов; если использовать только латинские буквы, то версия строки будет занимать 2000 байт плюс заголовок 24 байта.

Параметр fillfactor установить в 75%, чтобы на страницу помещалось только три версии и одна была доступна для обновления.

::

	CREATE DATABASE mvcc_hot;

::
	\c mvcc_hot

::
	CREATE TABLE t(
    s char(2000)
    ) WITH (fillfactor = 75, autovacuum_enabled = off);

autovacuum_enabled = off - отключение автоочистки таблицы.

Для изучения содержимого страницы используем расширение *pageinspect*.

::

	CREATE EXTENSION pageinspect;

Для удобства создать представление с расшифровкой поля t_infomask:


::

	CREATE VIEW t_v AS
	SELECT '(0,'||lp||')' AS ctid,
		   CASE lp_flags
			 WHEN 0 THEN 'unused'
			 WHEN 1 THEN 'normal'
			 WHEN 2 THEN 'redirect to '||lp_off
			 WHEN 3 THEN 'dead'
		   END AS state,
		   t_xmin || CASE
			 WHEN (t_infomask & 256) > 0 THEN ' (c)'
			 WHEN (t_infomask & 512) > 0 THEN ' (a)'
			 ELSE ''
		   END AS xmin,
		   t_xmax || CASE
			 WHEN (t_infomask & 1024) > 0 THEN ' (c)'
			 WHEN (t_infomask & 2048) > 0 THEN ' (a)'
			 ELSE ''
		   END AS xmax,
		   CASE WHEN (t_infomask2 & 16384) > 0 THEN 't' END AS hhu,
		   CASE WHEN (t_infomask2 & 32768) > 0 THEN 't' END AS hot,
		   t_ctid
	FROM heap_page_items(get_raw_page('t',0))
	ORDER BY lp;
	
Вставить строку и обновить ее, чтобы создать новую версию:

::

	INSERT INTO t(s) VALUES ('A');
	UPDATE t SET s = 'B';

Поскольку обновленный столбец не входит ни в какой индекс, в табличной странице появляется цепочка изменений:

::

	SELECT * FROM t_v;
	
	
ctid  | state  |  xmin   | xmax  | hhu | hot | t_ctid 

------+--------+---------+-------+-----+-----+--------

(0,1) | normal | 747 (c) | 748   | t   |     | (0,2)

(0,2) | normal | 748     | 0 (a) |     | t   | (0,2)


флаг hhu (Heap Hot Updated) показывает, что надо идти по цепочке ctid,
флаг hot (Heap Only Tuple) показывает, что на данную версию строки нет ссылок из индексов.

При дальнейших изменениях цепочка в пределах страницы будет расти:

::

	UPDATE t SET s = 'C';
	SELECT * FROM t_v;
	
ctid  | state  |  xmin   |  xmax   | hhu | hot | t_ctid 

------+--------+---------+---------+-----+-----+--------

(0,1) | normal | 747 (c) | 748 (c) | t   |     | (0,2)

(0,2) | normal | 748 (c) | 749     | t   | t   | (0,3)

(0,3) | normal | 749     | 0 (a)   |     | t   | (0,3)

