Блокировки строк
###################

Благодаря изоляции на основе снимков табличные строки не требуется блокировать при чтении. Но нельзя допустить,чтобы две транзакции изменяли
одну и ту же строку в один момент времени. Строки нужно блокировать, но внутренние механизмы не рассчитаны на
работу с огромным количеством одновременно существующих блокировок, которая должна возникать для каждой строки, поэтому тяжелые блокировки плохо подходят для этого 
(непомерные  накладные расходы и огромный объем оперативной памяти).

В некоторых СУБД идут по пути повышения уровня (эскалация): если уже заблокировано N строк таблицы, то при блокировке еще одной  блокируется вся таблица целиком, 
а блокировки на уровне строк  снимаются. Но в этом случае страдает пропускная способность.

В PostgreSQL сделано иначе. Информация о том, что строка  заблокирована, хранится исключительно в заголовке версии строки  внутри страницы данных. 
Там она представлена номером блокирующей транзакции (*xmax*) и дополнительными информационными битами.

За счет этого можно установить неограниченное количество блокировок уровня строки, и это не требует дополнительных ресурсов и не снижает  производительность системы.

Обратная сторона такого подхода — сложность организации очереди  ожидания. Так как без информации о блокировке в оперативной памяти другие процессы не могут встать в очередь. 
Ведь xmax - это просто поле. Как ждать поле или изменение признака?  
Для этого приходится использовать блокировки  уровня объектов, но удается обойтись очень небольшим их  количеством (пропорциональным числу процессов, а не числу  заблокированных строк).
Дождаться освобождения строки означает дождаться окончания блокирующей транзакции, а для этого нужно запросить блокировку ее номера. Таким образом, число 
используемых тяжелых блокировок пропорционально числу одновременно работающих процессов, а не количеству изменяемых строк.

.. note:: Очередь ожидания для исключительных блокировок строк организована с помощью блокировок объектов **tuple**

Блокировки на уровне строк блокируют только **запись в определённые строки**, но никак не влияют на выборку. 
Снимаются такие блокировки, как и блокировки на уровне таблицы, в конце транзакции или при откате к точке сохранения.

Режимы блокировки строки
************************

Существует четыре режима,в которых можно заблокировать троку. Два режима представляют *исключительные* блокировки, которые одновременно может удерживать только одна транзакция, 
и еще два — *разделяемые* блокировки, которые могут удерживаться несколькими транзакциями.

Матрица совместимости (конфликтов) выглядит следующим образом:

.. figure:: img/bl_str_01.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
 
	   
Исключительные режимы
=====================

Update и No Key Update


- Режим **Update** предполагает изменение любых полей строки или ее удаление (DELETE)

- **No Key Update** — изменение только тех полей,которые не входят в уникальные индексы (изменение, которое не затрагивает внешние ключи).

Команда *UPDATE* сама выбирает минимальный подходящий режим блокировки; поскольку ключи обычно не меняются, чаще всего строки блокируются в режиме *No Key Update*.

.. figure:: img/bl_str_02.png
       :scale: 100 %
       :align: center
       :alt: asda

При изменении или удалении строки в поле *xmax* актуальной версии записывается номер текущей транзакции. Установленное значение xmax, соответствующее активной транзакции, 
выступает в качестве блокировки.


То же самое происходит и при явном блокировании строки командой *SELECT FOR UPDATE*, но еще проставляется дополнительный информационный бит (*xmax lock only*), 
который говорит о том, что версия строки по-прежнему актуальна, хоть и заблокирована.

Режим блокировки определяется еще одним информационным битом (*keys updated*). Если другая транзакция намерена обновить или удалить заблокированную строку в несовместимом режиме, 
она будет вынуждена дождаться завершения транзакции с номером xmax. 

Бит XMax Lock Only станавливается в том случае, если выполняется команда SELECT FOR. Этот бит указывает не на изменение, а только на блокировка строки. 

Бит KeysUpdated, который показывает, что меняется ключевое поле.



Разделяемые режимы
==================

Разделяемые (shared) блокировки могут удерживаться несколькими транзакциями.

- **Share** применяется, когда нужно прочитать строку, но при этом нельзя допустить, чтобы она как-либо изменилась другой транзакцией. 

- Режим **Key Share** допускает изменение строки, но *только неключевых полей*. Данный режим автоматически используется ядром PostgreSQL при проверке внешних ключей.

Из матрицы совместимости видно, что:

- исключительные режимы конфликтуют между собой;

- разделяемые режимы совместимы между собой;

- разделяемый режим *Key Share* совместим с исключительным режимом *No Key Update* (при обновлении неключевых полей ключ не изменится)

.. important:: Для обычного чтения разделяемый режим блокировки не используется. При выполнении обычной команды SELECT (чтение данных) блокировки нет. 

Мультитранзакции
-----------------

Признаком блокировки является поле xmax, но разделяемые блокировки могут удерживаться несколькими транзакциями. В силу того,что прописать в поле можно только 
одно значение транзакции  для разделяемых блокировок применяются так называемые **мультитранзакции** (MultiXact). Мультитранзакция — это группа транзакций, 
которой присвоен отдельный номер. Детальная информация об участниках такой группы и режимах их блокировок хранится в файлах в каталоге **PGDATA/pg_multixact**. 
Страницы кешируются в общей памяти сервера для ускорения доступа и защищаются от сбоя журналом.

Им выделяются отдельные номера, которые соответствуют не одной транзакции, а целой группе.  Номер мультитранзакции имеет ту же размерность, что и обычный 
номер транзакции (32 бита). Чтобы отличить мультитранзакцию от обычной, используется еще один информационный бит (*xmax is multi*). 

.. figure:: img/bl_str_03.png
       :scale: 100 %
       :align: center
       :alt: asda


Если в разделяемом режиме блокировки к одной транзакции будут присоединяться другие в большом количестве, то это может привести к блокированию других транзакций 
на длительной основе, а также к переполнению счетчика (xid wraparound). 

Поэтому для номеров мультитранзакций тоже необходимо выполнять аналог заморозки — старые номера multixact id заменяются на новые 
(или на обычный номер, если в текущий момент блокировка уже удерживается только одной транзакцией).

*Обычная* заморозка версий строк выполняется для поля *xmin*, а для *мультитранзакций* речь идет о поле *xmax* актуальной версии строки, 
которая может оставаться актуальной, но при этом постоянно блокироваться разными транзакциями в разделяемом режиме.

За заморозку мультитранзакций отвечают параметры, аналогичные параметрам обычной заморозки (добавлено multiexact):

- vacuum_multixact_freeze_min_age = 5 000 000

- vacuum_multixact_freeze_table_age = 150 000 000

- autovacuum_multixact_freeze_max_age = 400 000 000

- vacuum_multixact_failsafe_age = 1 600 000 000

Практика
---------

Наиболее частый случай блокировок — блокировки, возникающие на уровне строк.

::

	CREATE DATABASE locks_rows;

::

	\c locks_rows

::

	CREATE TABLE accounts(acc_no integer PRIMARY KEY, amount numeric);

	INSERT INTO accounts VALUES (1,1000.00),(2,2000.00),(3,3000.00);

Поскольку информация о блокировке строк хранится только в самих версиях строк, а не в оперативной памяти, то извлекать информацию необходимо с 
помощью расширения *pageinspect*.

::
	
	CREATE EXTENSION pageinspect;

Для удобства создадим представление, расшифровывающее интересующие нас информационные биты в первых трех версиях строк.

::

	CREATE VIEW accounts_v AS
	SELECT '(0,'||lp||')' AS ctid,
		   t_xmax as xmax,
		   CASE WHEN (t_infomask & 1024) > 0  THEN 't' END AS committed,
		   CASE WHEN (t_infomask & 2048) > 0  THEN 't' END AS aborted,
		   CASE WHEN (t_infomask & 128) > 0   THEN 't' END AS lock_only,
		   CASE WHEN (t_infomask & 4096) > 0  THEN 't' END AS is_multi,
		   CASE WHEN (t_infomask2 & 8192) > 0 THEN 't' END AS keys_upd
	FROM heap_page_items(get_raw_page('accounts',0))
	WHERE lp <= 3
	ORDER BY lp;

В новом сеансе обновить сумму первого счета (**ключ не меняется**) и номер второго счета (**ключ меняется**):

::

	| \c locks_rows
	| BEGIN;

	| UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;
	| UPDATE accounts SET acc_no = 20 WHERE acc_no = 2;

Информация из представления:

::

	SELECT * FROM accounts_v;


	 ctid  | xmax | committed | aborted | lock_only | is_multi | keys_upd 
	-------+------+-----------+---------+-----------+----------+----------
	 (0,1) |  748 |           |         |           |          | 
	 (0,2) |  748 |           |         |           |          | t
	 (0,3) |    0 |           | t       |           |          | 


Строки, соответствующие первому и второму счету, заблокированы — в поле xmax записан номер блокирующей транзакции. 
Биты в столбце keys_upd показывают, что строки заблокированы в разных режимах.

Теперь в другом сеансе запросиить разделяемые блокировки первого и третьего счетов:

::

	|| \c locks_rows
	|| BEGIN;
	|| SELECT * FROM accounts WHERE acc_no = 1 FOR KEY SHARE;


	 acc_no | amount  
	--------+---------
		  1 | 1000.00
	(1 row)

::

	|| SELECT * FROM accounts WHERE acc_no = 3 FOR SHARE;


	 acc_no | amount  
	--------+---------
		  3 | 3000.00
	(1 row)

Все запрошенные блокировки совместимы друг с другом. В версиях строк видим:

::

	SELECT * FROM accounts_v;


	 ctid  | xmax | committed | aborted | lock_only | is_multi | keys_upd 
	-------+------+-----------+---------+-----------+----------+----------
	 (0,1) |    1 |           |         |           | t        | 
	 (0,2) |  748 |           |         |           |          | t
	 (0,3) |  749 |           |         | t         |          | 
	(3 rows)

Столбец lock_only позволяет отличить просто блокировку от обновления или удаления. 
Видим также, что в первой строке обычный номер в столбце xmax заменен на номер мультитранзакции — об этом говорит столбец is_multi.

Чтобы не вникать в детали информационных битов и реализацию мультитранзакций, можно воспользоваться еще одним расширением, 
которое позволяет увидеть всю информацию о блокировках строк в удобном виде.

::

	CREATE EXTENSION pgrowlocks;
	SELECT * FROM pgrowlocks('accounts') \gx

	-[ RECORD 1 ]-----------------------------
	locked_row | (0,1)
	locker     | 1
	multi      | t
	xids       | {748,749}
	modes      | {"No Key Update","Key Share"}
	pids       | {150478,150653}
	-[ RECORD 2 ]-----------------------------
	locked_row | (0,2)
	locker     | 748
	multi      | f
	xids       | {748}
	modes      | {Update}
	pids       | {150478}
	-[ RECORD 3 ]-----------------------------
	locked_row | (0,3)
	locker     | 749
	multi      | f
	xids       | {749}
	modes      | {"For Share"}
	pids       | {150653}

Расширение дает информацию о номерах транзакций, мультитранзакций и режимах всех блокировок.

::

	| ROLLBACK;

::

	|| ROLLBACK;

Очередь ожидания
****************

Исключительные режимы
=====================

Для организации очереди ожидания дополнительно используется  механизм блокировок объектов, при этом информация хранитсяв оперативной памяти и видна в *pg_locks*.

Из-за того, что блокировка строки — просто признак, очередь организована весьма нетривиально. Когда транзакция собирается изменить строку, она
выполняет следующую последовательность действий:


1) если поле xmax и информационные биты версии строки указывают на то,что строка заблокирована в *несовместимом* режиме,захватывает исключительную
тяжелую блокировку изменяемой версии строки (tuple);

2) при необходимости дожидается освобождения несовместимых блокировок, запрашивая блокировку номера транзакции xmax (или нескольких транзакций, если xmax — мультитранзакция);

3) прописывает в версию строки свой номер(в поле xmax)и устанавливает необходимые информационные биты;

4) освобождает блокировку версии строки, если она захватывалась в п.1.

Пункт 1 важен по причине того, что если строку одновременно пытаются обновить несколько транзакций, все они будут ждать завершения транзакции, работающей над строкой в данный момент. При завершении
этой транзакции между ожидающими возникнет состояние гонки за право обладания строкой, а это может привести к неопределенно долгому ожиданию для отдельных «невезучих» транзакций. 
Такая ситуация называется ресурсным голоданием (*starvation*). Блокировка версии строки выделяет первую в очереди транзакцию и гарантирует, 
что именно она получит блокировку следующей.

Если режимы блокировок конфликтуют, она должна каким-то образом встать в очередь, чтобы система «разбудила» ее, когда блокировка освободится. 
Но блокировки на уровне строк не предоставляют такой возможности — они никак не представлены в оперативной памяти, это просто байты внутри страницы данных.
Поскольку транзакция которая встает в очередь, запрашивает блокировку номера уже работающей транзакции. 

Когда транзакция работающая транзакция завершится, заблокированный ресурс освободится (при фиксации — просто исчезнет), транзакция, стоящая в очереди будет разбужена 
и сама сможет заблокировать строку (установить в xmax в соответствующую версию строки)

.. figure:: img/bl_str_04.png
       :scale: 100 %
       :align: center
       :alt: asda

