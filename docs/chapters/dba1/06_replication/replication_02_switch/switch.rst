Переключение на реплику
#######################

.. figure:: img/switch_01.png
       :scale: 100 %
       :align: center
       :alt: asda

Причиной перехода на резервный сервер может быть:

- необходимость проведения технических работ на основном сервере — тогда переход выполняется в удобное время в 
штатном режиме (switchover). 

- сбой основного сервера, и в таком случае переходить на резервный сервер нужно как можно быстрее, чтобы сократить время простоя системы (failover).

В любом случае сначала нужно убедиться, что мастер остановлен. Это очень важно, иначе данные на разных серверах «разойдутся».
Если возникнет ситуация, что на мастере, который выбыл из строя, продолжается работа, и туда какие-то запросы поступают, появляется информация, 
и на реплике, которая стала новым мастером, тоже появляются данные, то свести их потом воедино — нетривиальная и неавтоматизируемая задача. 
Скорее всего, часть данных придется просто потерять.


Затем выполняется переход на реплику в ручном режиме. Автоматизация этого процесса возможна, но требует стороннего кластерного программного обеспечения. 

Переключение состоит в разрыве цикла восстановления. Для этого реплике посылается команда **promote**: 

либо командой **pg_ctl promote**, 

либо вызовом функции **pg_promote** из SQL. 

Другой вариант — задать имя файла в параметре **promote_trigger_file**. При появлении в системе файла с таким именем восстановление прерывается.

Еще один вариант: удалить файл **standby.signal** и перезапустить резервный сервер. Это не вполне «честный» способ, поскольку в этом случае реплика не поймет, 
что восстановление завершено, и не перейдет на новую линию времени. 

Необходимые действия
=====================

.. figure:: img/switch_02.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
Получив сигнал, сервер завершает восстановление и переходитв обычный режим работы.

Для этого он применяет уже полученные журнальные записи, которые еще не были применены.

Процессы **walreceiver и startup** завершают свою работу — на основном сервере они не нужны. 
А вот процессы **wal writer** и **autovacuum launcher**, наоборот, запускаются.

Кроме того, сервер переходит на новую линию времени.

С точностью до некоторых деталей, все происходит так же, как при окончании восстановления из резервной копии.
	   
Практика
-------

**Настройка потоковой репликации**

Настроить реплику так же, как делали ранее. А после нужно выполнить переход на нее.

Создаем автономную резервную копию, попросив утилиту создать слот и необходимые файлы (postgresql.auto.conf с настройками и standby.signal).

::

	[admin@PG ~]$ pg_basebackup --pgdata=/home/admin/backup -R --slot=replica

Выкладываем копию в каталог PGDATA сервера B:

::

	[admindb@PG ~]$ sudo -u postgres rm -fr /var/lib/pgsql/data1
	[admindb@PG ~]$ sudo mv /home/admin/backup /var/lib/pgsql/data1
	[admindb@PG ~]$ sudo chown -R postgres:postgres /var/lib/pgsql/data1
	


::

	[admindb@PG ~]$ sudo sed -i 's/#port = 5432/port = 5433/g' /var/lib/pgsql/data1/postgresql.conf

	Запускаем реплику:	

::

	[admindb@PG ~]$ sudo -u postgres pg_ctl -D /var/lib/pgsql/data1 start


Проверим настроенную репликацию. Выполним несколько команд на мастере:

::

	A@postgres=#CREATE DATABASE replica_switchover;

	CREATE DATABASE

::

	A@postgres=#\c replica_switchover
	
	You are now connected to database "replica_switchover" as user "postgres".

::

	A@replica_switchover=#CREATE TABLE test(s text);

	CREATE TABLE


::

	A@replica_switchover=#INSERT INTO test VALUES ('Переключение на реплику!');

	INSERT 0 1
	
Проверим реплику:

::

	[admindb@PG ~]$ psql -U postgres -p 5433

::

	| B@postgres=#\c replica_switchover


	| B@replica_switchover=#SELECT * FROM test;

	s
	--------------------------
	 Переключение на реплику!
	(1 row)

**Переход на реплику**

Сейчас сервер B является репликой (находится в режиме восстановления):

::

	B@replica_switchover=#SELECT pg_is_in_recovery();

	 pg_is_in_recovery 
	-------------------
	 t
	(1 row)

Повышаем реплику. В версии 13 появилась функция pg_promote(), которая выполняет то же действие.

::

	sudo -u postgres pg_ctl -D /var/lib/pgsql/data1 promote

Теперь бывшая реплика стала полноценным экземпляром.

::
	
	B@replica_switchover=#SELECT pg_is_in_recovery();

	 pg_is_in_recovery 
	-------------------
	 f
	(1 row)

Мы можем изменять данные:

::

	B@replica_switchover=#INSERT INTO test VALUES ('Реплика стала мастером');
	
	INSERT 0 1
	
Восстановение сервера
*********************

.. figure:: img/switch_03.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
Если переход на реплику не был вызван выходом сервера из строя,то нужен способ быстро вернуть старый мастер в строй — 
теперь ужев качестве реплики (failback).

Возможно несколько вариантов.

Простое подключение
===================

.. figure:: img/switch_04.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
В случае аккуратной остановки мастера (останов в режимах **fast** или **smart**) все журнальные записи мастера скорее всего 
дойдут до реплики, хотя это и не гарантируется. Процесс останова организован таким образом, 
что сначала отключаются все обслуживающие процессы, затем выполняется контрольная точка, и только в самую последнюю 
очередь останавливается процесс **wal sender**, чтобы реплика успела получить запись WAL о контрольной точке.

Позицию в журнале мастера можно проверить с помощью утилиты **pg_controldata** («Latest checkpoint location»), 
а позицию на реплике покажет функция **pg_last_wal_receive_lsn()**. Поскольку функция **pg_last_wal_receive_lsn()** 
показывает следующую позицию, то ее значение должно опережать **latest_checkpoint_location** на длину записи 
(120 байт в PostgreSQL 13). Если это так, то бывший мастер можно непосредственно подключить к новому, 
изменив соответствующим образом конфигурационные параметры.

В случае останова мастера без выполнения контрольной точки (сбой или режим **immediate**), 
такое подключение в принципе невозможно: сервер не стартует, а в журнале сообщений будет зафиксирована ошибка.

Резервная копия
===============

.. figure:: img/switch_05.png
       :scale: 100 %
       :align: center
       :alt: asda

Если мастер был остановлен аварийно, велика вероятность того, что часть журнальных записей не успела дойти до реплики. 
В этом случае просто так подключать мастер нельзя.

Простой и надежный вариант — создать абсолютно новую реплику путем изготовления и развертывания базовой резервной копии. 
То есть создается копия реплики (новый мастер) через pg_basebackup и подключается уже абсолютно новый сервер 
к абсолютно новой копии к бывшей реплике (новый мастер) в качестве реплики.
Однако для больших баз данных этот процесс может занимать много времени.

Вариант такого подхода — не использовать утилиту **pg_basebackup**,а сделать копию с помощью **API резервирования** с
использованием утилиты **rsync**. Если выполнять копирование сразу после переходана реплику, то большая часть файлов не 
должна успеть поменяться и процесс может пройти существенно быстрее. Но это усложняет процесс.

Утилита pg_rewind
=================

.. figure:: img/switch_06.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
Еще более быстрый вариант состоит в использовании штатной утилиты **pg_rewind**.

**pg_rewind** нужно передать в параметрах информацию о том, что является бывшим мастером (бывшим основным сервером). 
Это так называемый *целевой сервер*, а также передать информацию о том, что является *серверным источником*.

Утилита определяет место расхождения между двумя серверами, определяет ближайшую к нему общую контрольную точку, и, 
просматривая журнал, определяет все страницы, измененныес момента этой контрольной точки.

Найденные страницы (которых должно быть немного) заменяются страницами с сервера-источника (нового мастера). 
То есть те страницы в файлах данных, которые изменились на целевом сервере (на бывшем мастере) она заменит теми страницами, 
которые возьмет из реплики. Кроме того, утилита копирует с сервера-источника все служебные файлы. 

Дальше применяются все необходимые записи WAL с нового мастера. Фактически, это выполняет уже не утилита, 
а обычный процесс восстановления после запуска сервера. Чтобы восстановление началось с нужного момента, 
утилита создает управляющий файл **backup_label**.

Ограничения re_wind
-------------------

Утилита имеет ряд особенностей, ограничивающих ее применение. Необходимо, в числе прочего:

- Все сегменты WAL от текущего момента до найденной контрольной точки должны находиться в каталоге **pg_wal** целевого сервера 
или быть доступны для получения из архива, в этом случае надо задать параметр **restore_command** и ключ **--restore-target-wal**.

- Первое изменение данных после контрольной точки должно вызывать запись в WAL полной страницы. 
Параметра **full_page_writes = on** недостаточно, поскольку он не учитывает «незначительные» изменения страниц 
(они называются *hint bits*). Дополнительно требуется, чтобы либо кластер был инициализирован с контрольными суммами страниц, 
либо нужно устанавливать параметр **wal_log_hints = on**.

- Целевой сервер должен быть остановлен аккуратно, с выполнением контрольной точки. 
Если это не так, утилита по умолчанию запустит целевой сервер и тут же остановит его корректно.

- На сервере-источнике заранее должен быть установлен параметр **full_page_writes = on** — причина та же, что и при 
восстановлении из резервной копии: утилита может скопировать страницы в рассогласованном состоянии.

Практика
--------

**Утилита pg_rewind**

Сервер **А** еще не выключен и тоже может изменять данные:

::

	A@replica_switchover=#INSERT INTO test VALUES ('Die hard');

В реальности такой ситуации необходимо всячески избегать, поскольку теперь непонятно, какому серверу верить. 
Придется либо полностью потерять изменения на одном из серверов, либо придумывать, как объединить данные.

Наш выбор — потерять изменения, сделанные на первом сервере.

Мы планируем использовать утилиту **pg_rewind**, поэтому убедимся, что включены контрольные суммы на страницах данных:

::

	A@replica_switchover=#SHOW data_checksums;
	
	 data_checksums 
	----------------
	 on
	(1 row)

Этот параметр служит только для информации; изменить его нельзя — подсчет контрольных сумм задается при инициализации 
кластера или утилитой **pg_checksums** на остановленном сервере.

Остановим целевой сервер (A) некорректно.

::

	[admin@PG ~]$ sudo head -n 1 /var/lib/pgsql/data/postmaster.pid

	41792
	
::

	[admin@PG ~]$ sudo kill -9 41792

Создадим на сервере-источнике (B) слот для будущей реплики:

::

	B@postgres=#SELECT pg_create_physical_replication_slot('replica');

	 pg_create_physical_replication_slot 
	-------------------------------------
	 (replica,)
	(1 row)

И проверим, что параметр full_page_writes включен:

::

	B@postgres=#SHOW full_page_writes;

	 full_page_writes 
	------------------
	 on
	(1 row)

Если целевой сервер не был остановлен корректно, утилита сначала запустит его в монопольном режиме и 
остановит с выполнением контрольной точки. Для запуска требуется наличие файла **postgresql.conf** в PGDATA.

::

	[admin@PG ~]$ sudo touch /var/lib/pgsql/data/postgresql.conf


В ключах утилиты pg_rewind надо указать каталог PGDATA целевого сервера и способ обращения к серверу-источнику: 
либо подключение от имени суперпользователя (если сервер работает), либо местоположение его каталога PGDATA (если он выключен).

::

	[admin@PG ~]$ sudo -u postgres /usr/bin/pg_rewind -D /var/lib/pgsql/data --source-server='user=postgres port=5433' -R -P
	
.. figure:: img/switch_08.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
В результате работы **pg_rewind** «откатывает» файлы данных на ближайшую контрольную точку до того момента, 
как пути серверов разошлись, а также создает файл **backup_label**, который обеспечивает применение нужных журналов 
для завершения восстановления.

Заглянем в backup_label:

::

	[admin@PG ~]$ sudo cat /var/lib/pgsql/data/backup_label

.. figure:: img/switch_09.png
       :scale: 100 %
       :align: center
       :alt: asda

Ключом -R мы попросили утилиту создать сигнальный файл **standby.signal** и задать в конфигурационном файле строку соединения.

student$ sudo ls -l /var/lib/postgresql/13/alpha/standby.signal

-rw------- 1 postgres postgres 0 янв 16 12:18 /var/lib/postgresql/13/alpha/standby.signal

student$ sudo cat /var/lib/postgresql/13/alpha/postgresql.auto.conf
# Do not edit this file manually!
# It will be overwritten by the ALTER SYSTEM command.
primary_conninfo = 'user=student passfile=''/home/student/.pgpass'' channel_binding=prefer host=''/var/run/postgresql'' port=5432 sslmode=prefer sslcompression=0 sslsni=1 ssl_min_protocol_version=TLSv1.2 gssencmode=prefer krbsrvname=postgres target_session_attrs=any'
primary_slot_name = 'replica'
primary_conninfo = 'user=postgres passfile=''/var/lib/postgresql/.pgpass'' channel_binding=prefer port=5433 sslmode=prefer sslcompression=0 sslsni=1 ssl_min_protocol_version=TLSv1.2 gssencmode=prefer krbsrvname=postgres target_session_attrs=any'
Утилита добавляет строку для primary_conninfo в конец существующего файла конфигурации, поэтому остальные настройки (primary_slot_name) продолжат действовать.

Можно стартовать новую реплику.

student$ sudo pg_ctlcluster 13 alpha start
Слот репликации инициализировался и используется:

β=> SELECT * FROM pg_replication_slots \gx
-[ RECORD 1 ]-------+----------
slot_name           | replica
plugin              | 
slot_type           | physical
datoid              | 
database            | 
temporary           | f
active              | t
active_pid          | 13484
xmin                | 
catalog_xmin        | 
restart_lsn         | 0/5037998
confirmed_flush_lsn | 
wal_status          | reserved
safe_wal_size       | 

Данные, измененные на новом мастере, получены:

student$ psql -p 5432 -d replica_switchover
α=> SELECT * FROM test;
                 s                  
------------------------------------
 Привет, мир!
 Я - бывшая реплика (новый мастер).
(2 rows)

Проверим еще:

β=> INSERT INTO test VALUES ('Еще строка с нового мастера.');
INSERT 0 1
α=> SELECT * FROM test;
                 s                  
------------------------------------
 Привет, мир!
 Я - бывшая реплика (новый мастер).
 Еще строка с нового мастера.
(3 rows)

Таким образом, два сервера поменялись ролями.