Физическая репликация
#####################

.. note:: Репликация PostgreSQL — это метод копирования данных с одного сервера базы данных на другой сервер в режиме реального времени. 
          Этот процесс обеспечивает безопасность и доступность данных, помогает поддерживать бесперебойную работу системы даже во время сбоев сервера. 
		  
		  Некоторые цели использования репликации:
		  
		  Повышение отказоустойчивости. Если один из серверов выйдет из строя, то остальные продолжат работу.
		  
		  Повышение производительности. Распределение данных по серверам в разных частях страны или мира повышает скорость доступа к данным для местных пользователей.


.. figure:: img/fizrepl_01.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
Не смотря на то, что работать на одном сервере удобнее, одиночный сервер, управляющий базами данных, может не удовлетворять требованиям, предъявляемым к системе. 
Есть две основных задачи, для решения которых требуется наличие нескольких серверов.

- отказоустойчивость: один физический сервер — это возможная точка отказа. Если сервер выходит из строя, система становится недоступной.

- производительность (масштабируемость). Один сервер может не справлятьсяс нагрузкой. Зачастую желательна возможность не вертикального, а горизонтального 
масштабирования — распределения нагрузки на несколько серверов. Дело может быть как в стоимости аппаратуры, так и в необходимости различных настроек для 
разных типов нагрузки (например, для OLTP и отчетности).

В случае PostgreSQL распределенные системы строятся по принципу «shared nothing»: несколько серверов работают независимо друг от друга и не имеют ни 
общей оперативной памяти, ни общих дисков. Следовательно, если серверы должны работать с одними и теми же  данными, то эти данные требуется 
синхронизировать между ними. 

Механизм синхронизации и называется репликацией.

Мастер и реплика
****************

.. figure:: img/fizrepl_02.png
       :scale: 100 %
       :align: center
       :alt: asda

При физической репликации серверы имеют назначенные роли: один является **ведущим** («мастер») и один или несколько серверов являются **ведомыми** («реплики»).

Мастер передает на реплику журнальные записи, а реплика тут же применяет эти записи к своим файлам данных. 
Применение происходит чисто механически, без «понимания смысла» изменений, и выполняется быстрее, чем работало бы повторное выполнение операторов SQL.
Таким образом появляется точная копия основного сервера, но с некоторым запозданием.

Но при этом критична двоичная совместимость между серверами — они должны работать на одной и той же программно-аппаратной платформе и на них должны 
быть запущены одинаковые основные версии PostgreSQL. Потому что журнальные файлы — это некая информация, которая позволяет повторить операцию, 
но физически это просто какие-то фрагменты страниц. А страницы зависят от архитектуры (может зависеть порядка байт в числе, может зависеть от разрядности 
и от других факторов) Поэтому реплика и мастер должны работать на одном и том же железе, с одной и той же системой, с одной и той же основной версии Postgres.


Поскольку журнал является общим для всего кластера, то и реплицировать можно только кластер целиком, а не отдельные базы данных или таблицы. 
Возможность «отфильтровать» журнальные записи по базам данных отсутствует. Поток этот идет всегда в одну сторону от мастера к реплике, весь журнал WAL. 

Реплика не может генерировать собственных журнальных записей, она лишь применяет записи мастера. 

Поэтому при таком подходе реплика может быть доступна только для чтения — никакие операции, изменяющие данные, на реплике не допустимы.

Потоковая репликация
********************

.. figure:: img/fizrepl_03.png
       :scale: 100 %
       :align: center
       :alt: asda

Обычно на практике, применяется потоковая репликация. То есть основной сервер с резервным общаются по потоку репликаций, точно так же как , 
утилита pg_basebackup, подключается к основному серверу и вытягивает из него журнальные записи. Так происходит и в данном случае. 

Реплика запускает у себя процесс, который называется wal-reciver. Этот процесс подключается по протоколу репликации к основному серверу, 
а основной сервер запускает процесс wal-sender, который поставляет wal-reciver журнальные записи. 

Кроме этого, на реплике *постоянно работает* процесс **startup**. Он что восстанавливает согласованность, когда сервер запускается после сбоя.
В случае репликации этот процесс запущен и он все время работает. 

**Wal-reciver** получает журнальные записи, а **startup** эти записи проигрывает, и таким образом реплика догоняет мастер. 

Также используется слот репликации (на рис. кружок). Слот репликации здесь используется для того, чтобы мастер знал о том, 
что к нему осуществлено подключение и нельзя  преждевременно удалять те журнальные файлы, которые реплике не передавались.

Практика
========

**Настройка потоковой репликации**

Поскольку в конфигурации не будет архива журнала предзаписи, важно на всех этапах использовать слот репликации — 
иначе при определенной задержке мастер может успеть удалить необходимые сегменты и весь процесс придется повторять с самого начала.

Создание слота:

::

	A@postgres=#SELECT pg_create_physical_replication_slot('replica');

.. figure:: img/fizrepl_04.png
       :scale: 100 %
       :align: center
       :alt: asda

Проверка созданного слота:

::

	A@postgres=#SELECT * FROM pg_replication_slots \gx
	
.. figure:: img/fizrepl_05.png
       :scale: 100 %
       :align: center
       :alt: asda

Вначале слот не инициализирован (**restart_lsn** и **wal_status** пустые).

Все необходимые настройки есть по умолчанию:

wal_level = replica;

max_wal_senders;

разрешение на подключение в pg_hba.conf.

Создание автономной резервной копии с использованием созданного слота. 
Копию расположим в подготовленном каталоге. С ключом -R утилита создает файлы, необходимые для будущей реплики.

::

	[admin@PG ~]$ pg_basebackup --pgdata=/home/admin/backup -R --slot=replica

Снова проверим слот:

::

	A@postgres=#SELECT * FROM pg_replication_slots \gx

.. figure:: img/fizrepl_06.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
	-[ RECORD 1 ]-------+----------
	slot_name           | replica
	plugin              | 
	slot_type           | physical
	datoid              | 
	database            | 
	temporary           | f
	active              | f
	active_pid          | 
	xmin                | 
	catalog_xmin        | 
	restart_lsn         | 0/4000000
	confirmed_flush_lsn | 
	wal_status          | reserved
	safe_wal_size       | 

После выполнения резервной копии слот инициализировался, и мастер теперь хранит все файлы журнала с начала копирования 
(restart_lsn, wal_status).

Примерно то же самое хранится в **backup_label**:

::

	[admin@PG ~]$ head -n 1 /home/admin/backup/backup_label

.. figure:: img/fizrepl_07.png
       :scale: 100 %
       :align: center
       :alt: asda

Файл **postgresql.auto.conf** был подготовлен утилитой **pg_basebackup**, поскольку мы указали ключ **-R**. 
Он содержит информацию для подключения к мастеру (**primary_conninfo**) и имя слота репликации (**primary_slot_name**):

::

	[admin@PG ~]$ cat /home/admin/backup/postgresql.auto.conf


# Do not edit this file manually!
# It will be overwritten by the ALTER SYSTEM command.
primary_conninfo = 'user=student passfile=''/home/student/.pgpass'' channel_binding=prefer host=''/var/run/postgresql'' port=5432 sslmode=prefer sslcompression=0 sslsni=1 ssl_min_protocol_version=TLSv1.2 gssencmode=prefer krbsrvname=postgres target_session_attrs=any'
primary_slot_name = 'replica'
По умолчанию реплика будет «горячей», то есть сможет выполнять запросы во время восстановления. Если такая возможность не нужна, реплику можно сделать «теплой» (hot_standby = off).

Утилита также создала сигнальный файл **standby.signal**, наличие которого указывает серверу войти в режим постоянного восстановления.

::

	[admindb@PG ~]$ ls -l /home/admin/backup/standby.signal

Выкладываем резервную копию в каталог данных сервера beta.

::

	[admindb@PG ~]$ sudo -u postgres rm -fr /var/lib/pgsql/data1
	[admindb@PG ~]$ sudo mv /home/admin/backup /var/lib/pgsql/data1
	[admindb@PG ~]$ sudo chown -R postgres:postgres /var/lib/pgsql/data1
	
Поменять порт для запуска второго сервера

::

	[admindb@PG ~]$ sudo sed -i 's/#port = 5432/port = 5433/g' /var/lib/pgsql/data1/postgresql.conf

Журнальные записи, необходимые для восстановления согласованности, реплика получит от мастера по протоколу репликации. 
Далее она войдет в режим непрерывного восстановления и продолжит получать и проигрывать поток записей.

::

	[admindb@PG ~]$ sudo -u postgres pg_ctl -D /var/lib/pgsql/data1 start

Репликация и архивация
**********************

.. figure:: img/fizrepl_08.png
       :scale: 100 %
       :align: center
       :alt: asda
	   
Другой способ доставки журнальных записей состоит в том, чтобы предоставить реплике доступ к архиву журналов — точно так же, 
как при обычном восстановлении из архива. запустится процесс **archiver* который будет копировать WAL архив, 
 реплика сможет из этого архива файлы забирать.

Если реплика по каким-то причинам не сможет получить очередную журнальную запись по протоколу репликации 
(например, из-за обрыва связи), она попробует прочитать ее из архива с помощью команды, заданной в параметре **restore_command**. 

Переключение произойдет автоматически, и когда реплика из архива все файлы заберет она будет пробовать переключиться обратно на 
потоковую репликацию, чтобы забирать файлы быстрее по потоку. При восстановлении связи реплика снова автоматически переключится на использование потоковой репликации.

В принципе, репликация может работать и с одним только архивом, без потоковой репликации. Но в этом случае:

- реплика вынужденно отстает от мастера на время заполнения сегмента;

- мастер ничего не знает о существовании реплики, что в некоторых случаях может привести к проблемам.

Также архив позволяет обойтись без слота репликации, потому что слот это всегда необходимость мониторинга. 
При использовании слота на основном сервере могут переполнится диски журнальными файлами. 

Очистка архива
**************

.. figure:: img/fizrepl_09.png
       :scale: 100 %
       :align: center
       :alt: asda

Если архив используется только для синхронизации одной реплики, можно настроить его автоматическую очистку, 
для этого в параметре **archive_cleanup_command** задается команда, которая будет выполняться по окончании каждой 
точки рестарта подобно тому, как после каждой контрольной точки удаляются файлы журнала. 

В команде удобно вызывать утилиту **pg_archivecleanup**: 

::

	archive_cleanup_command = 'pg_archivecleanup /path/to/archive %r'

1. Когда проходит определенное время, либо накапливается определенное количество журнальных файлов, выполняется контрольная точка. 
Она позволяет удалить те журнальные файлы, которые уже не нужны для восстановления. 

2. Запись о контрольной точке приходит по протоколу репликации к реплике, и реплика в этот момент выполняет точку рестарта. 
Она удаляет у себя лишние файлы, которые ей уже не потребуются для того, чтобы можно было продолжить восстановление, 
если вдруг что-то случится. На реплике в процессе восстановления может произойти какой-то сбой и начинать восстановление необходимо будет 
не с самого начала, а с какой-то точки. Это точка рестарта.

3. При достижении точки рестарта **checkpointer** будет вызывать эту команду, которая будет прописана в параметр, 
и она из архива тоже будет удалять файлы, которые не нужны. Таким образом  размер архива можно ограничить, если он нужен только для
поддержки реплики. 
